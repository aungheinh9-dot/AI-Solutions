# Methodology Section
## AI Solutions Website Project

## Hybrid System Development Model

In software development fully functioning systems or applications are designed and developed through a series of steps. There are multiple variations to these steps that come in the form of software development models/methodologies. The waterfall model is one of these variations. It is a sequential software development model where stages are followed in a sequential manner one after the other. However, over time this models' weaknesses became apparent. It was found to be too rigid and not flexible enough to facilitate the ever-changing user requirements presented by clients. As a result, varying agile methodologies were introduced over time. These were found to be more flexible, and allowed for the ever-changing conditions during software development. Much like the waterfall model however the agile model in general had its own flaws one of them being the difficulty in predicting a projects timeline. As a result, some organisations came up with ways of combining the waterfall model and a general agile model. This resulted in a hybrid model that attempts to maximise the strengths of both methodologies, and minimise their weaknesses. The steps taken when implementing such a model were similar to that of the waterfall model. The difference being the development and testing stages were iterative and done halfway in the development life cycle. This stage was then followed by deployment and the final outcome.

## Requirements Gathering and Scheduling

The project at hand was to design a web-based system that would serve as a comprehensive website for an AI Solutions company. The system was required to advertise AI services, showcase past projects, display company information, and provide a means for potential clients to contact the company. Based on the requirements received it was decided that a hybrid of waterfall and agile models be used, due to its strengths. The information presented allowed functional and non-functional system requirements to be gathered. Functional requirements included the need for multiple information pages (Home, Services, About, Projects, Articles, Events, Contact), an interactive AI chatbot, a contact form for customer inquiries, and a password-protected admin panel for managing inquiries. Non-functional requirements included responsive design for all devices, modern UI/UX with dark theme, secure data handling, and cross-browser compatibility.

Possible constraints were identified and were to be taken into consideration during the course of the project. These constraints included the need for a lightweight solution that could work as a static website without requiring complex server setup, the requirement for real-time data storage for customer inquiries, and the need for secure authentication for the admin panel. The hardware and software required to develop the system were identified and configured accordingly. The development environment required a code editor (such as Visual Studio Code), a web browser for testing, Node.js for optional local server development, and access to Firebase services for database and authentication. Methods of evaluation once the system was complete were determined and to be used to evaluate the system upon completion. These included functional testing of all pages and features, responsive design testing across devices, cross-browser compatibility testing, and security testing for the admin panel.

Much like any project in a real-world scenario a client was present. The client was presented with a requirements specification to determine whether the requirements gathered were indeed correct and adequate. The requirements specification detailed the 17 pages to be developed (main pages, service detail pages, project detail pages, and admin panel), the interactive features (AI chatbot, contact form, admin dashboard), the design requirements (dark theme with cyan/emerald color scheme), and the technology stack (HTML5, CSS3, JavaScript, Tailwind CSS, Firebase). Once the requirements specification was signed off on, the product development schedule could be generated. The schedule detailed all the tasks to be carried out during the course of the project from the requirements specification to the written evaluation. Amendments were made to the schedule where necessary to signify the various changes in time allocations of each task. Tasks were allocated time on the bases of experience and technical skill. The simpler tasks such as creating basic HTML page structures were allocated the least time while the more challenging and complex tasks such as implementing the AI chatbot, Firebase integration, and admin panel authentication were given more time.

Once the schedule write up was complete the software to be used in development was downloaded. The application was to be developed with a modern code editor. **Visual Studio Code** was chosen as the primary development environment due to its compatibility with web development, built-in terminal, extensive extension library, and excellent support for HTML, CSS, and JavaScript. This interface enables the IDE to run commands if the need arises, such as starting a local development server or running build commands. Visual Studio Code also provides features such as syntax highlighting, code completion, and integrated debugging which assist in the development process reducing development times.

Front end development was done using **HTML5, CSS3, and JavaScript (ES6+)** which incorporated semantic HTML for structure, modern CSS for styling, and JavaScript for interactive functionality. When developing with HTML and CSS, styling frameworks such as **Tailwind CSS** were incorporated into the application being developed. Tailwind CSS is useful in styling components which enhances their look and feel through utility classes that enable rapid development while maintaining design consistency. HTML elements such as forms, navigation bars, and cards are styled to be more visually pleasing than standard HTML elements. Tailwind CSS's responsive utilities (sm:, md:, lg: breakpoints) ensure that the website adapts gracefully to different screen sizes.

Backend development was done using **Firebase Firestore and Firebase Authentication** which makes use of cloud-based services. Firebase is lightweight and makes use of various libraries and SDKs to run. Development is also made faster through the use of Firebase's JavaScript SDK which can be integrated directly into HTML pages, eliminating the need for separate backend server setup. Firebase Firestore provides real-time database capabilities, allowing data to be stored and retrieved without complex server-side code. Firebase Authentication provides secure user authentication for the admin panel. Configurations were done on the development environment ensuring it had all the necessary tools and extensions to develop the system. During the course of the project however more libraries were required and were therefore downloaded, such as Font Awesome for icons and Google Fonts for typography.

The **Firebase Firestore database** was set up through the Firebase Console. It facilitated the connection between the Firebase database and the frontend JavaScript code. Collections were created in Firestore for storing customer inquiries, with documents containing fields such as name, email, phone, company, country, jobTitle, projectDetails, status, and timestamp. The database structure was accessible via the Firebase Console user interface and could be queried through the Firebase JavaScript SDK in the frontend code. Having configured the development software and Firebase services, front end designs were next to be done.

## System Design

This entailed viewing existing applications that were similar in their function to the system to be developed. This was done to gain an idea of how this type of website should be in general. Research was conducted on existing AI solution provider websites to understand industry standards for layout, navigation, content presentation, and user experience. An application logo, wireframe and mock-up for the front-end system interface were designed. The logo featured a brain icon with gradient colors (cyan, emerald, blue) to represent AI and innovation. The wireframe outlined the structure of all 17 pages, showing navigation flow, content sections, and interactive elements placement.

The design took some aspects from existing systems such as the manner in which they display content, the use of dark themes for tech companies, and the implementation of interactive chatbots. The design was made to be simple for easy navigation by users. The navigation bar was designed to be consistent across all pages, with clear labels and a mobile-responsive hamburger menu. The design was also meant to be presentable so that the users can clearly understand what they are viewing. A mock-up of what the application pages would look like was generated to depict the look and feel of the application once complete. This showed the colors (cyan #06b6d4, emerald #10b981, blue #3b82f6, gray-900 #111827 for backgrounds), icons (Font Awesome), and logos that the application would display once functioning.

The color scheme was carefully selected to match client requirements for a modern, tech-forward appearance. The dark theme with cyan and emerald accents was chosen to represent innovation, technology, and professionalism. The color palette included primary colors (cyan-500, emerald-500, blue-500), background colors (gray-900, gray-800, gray-700), and text colors (white, gray-300, gray-400). Gradient combinations were designed for buttons, logos, and special elements, such as linear gradients from cyan to emerald, and triple gradients from cyan through emerald to blue.

The back end was designed with the use of **Firebase Firestore database schema** that depicted the various collections and documents that would enable the system to function accordingly. Each function had a set of data structures that enable that function. An illustration can be customer inquiry submissions. There is a Firestore collection named "inquiries" which stores documents for each customer submission. Each document contains fields such as name (string), email (string), phone (string), company (string), country (string), jobTitle (string), projectDetails (string), status (string: "New", "In Progress", "Completed"), and timestamp (timestamp). The Firestore security rules were designed to allow public write access for inquiry submissions while restricting read access to authenticated admin users only.

A **JavaScript service layer** exists that retrieves data from the front end for storage in the database. It also retrieves data from the database to be sent to the front end for display in the admin panel. The service layer is implemented through JavaScript modules such as `forms.js` for handling contact form submissions and `firebase-config.js` for Firebase initialization and data operations. The service layer contains the logic needed to either store or retrieve data from the database using Firebase SDK methods such as `addDoc()` for creating documents, `getDocs()` for retrieving documents, and `updateDoc()` for updating document fields.

A use case diagram was generated to depict the overall system, its functions and users. In the case of the project the actors were the potential clients visiting the website and the administrators managing the system. The clients have access to functions such as viewing company information, browsing services and projects, reading articles, viewing event galleries, interacting with the AI chatbot, and submitting contact inquiries. The administrators have access to more functions as they can not only view the public website but are also involved in managing customer inquiries, updating inquiry statuses, filtering inquiries, and viewing statistics in the admin dashboard.

A **database schema diagram** was drawn depicting all the collections and documents that the application was to use. The main collection was "inquiries" which stores customer contact form submissions. Each document in the collection is independent with no relationships to other documents, making the data structure simple and scalable. The schema included field types, required fields, and validation rules to ensure data integrity.

## Development and Testing

Development of the application was then carried out beginning with the front end followed by the backend integration. **HTML5, CSS3, and JavaScript (ES6+)** were used with all their modern features, libraries and APIs. In HTML development, each page is a separate HTML file which encompasses HTML for structure, CSS (Tailwind CSS and custom CSS) for styling, and JavaScript for interactive functionality. Pages are generated to define a section or view for the application. An illustration could be a home page (`index.html`), a services page (`services.html`), or a contact page (`contact.html`).

For the AI Solutions application multiple HTML pages were generated for every section the application was to have. The application was to have two main views. The public users or any interested clients would have access to a main view. This view would display a home page, services overview page, individual service detail pages (6 pages: Machine Learning, NLP, Computer Vision, Predictive Analytics, Process Automation, AI Chatbots), about page, projects overview page, individual project detail pages (3 pages: E-commerce AI Assistant, Healthcare Analytics Platform, Smart Manufacturing System), articles page, galleries page, and contact page. The home page displayed company information, featured services, customer testimonials, and key statistics. Details on the AI services to be offered were listed on the services pages. Those wanting to learn more about specific services could view the detailed service pages with interactive demos. The contact page was where potential clients could submit inquiries about their project needs.

The application was to also have an **admin view** for the administrators. It could be likened to an administrator's dashboard. The admin view displayed an admin panel (`admin.html`) with inquiry management functionality. The admin panel allowed administrators to view all customer inquiries in a table format, filter inquiries by status, update inquiry statuses (New, In Progress, Completed), view inquiry details in modals, and see statistics about total inquiries, pending inquiries, and completed inquiries. The admin panel required authentication through a login form before access was granted.

Pages were generated for each of those sections and coding was implemented to each page according to the designs done prior to development. The modular HTML structure enables a developer to adequately organize their code according to its purpose. In the case of the application each page served a specific function. Debugging specific issues was made easier since the location of the code pertaining to that problem is known. HTML pages being separate files require navigation links that are used to navigate to them. An example could be `index.html` as the home page, `services.html` as the services overview page, and `contact.html` as the contact page. The navigation bar in each page contains links to all major sections, ensuring consistent navigation throughout the application.

This navigation structure was necessary for navigation of the application, without it navigation would not be possible. The navigation was implemented using HTML anchor tags (`<a>`) with `href` attributes pointing to the respective HTML files. The navigation bar was made responsive using Tailwind CSS classes, with a desktop horizontal menu and a mobile hamburger menu that toggles on smaller screens. When sending and retrieving data from the backend, JavaScript makes use of **Firebase SDK methods** that all the pages can use to do this. The Firebase configuration was set up in a separate JavaScript file (`firebase-config.js`) and Firebase SDK methods were implemented to send or retrieve data for the pages that needed to do so.

In JavaScript the **Firebase `addDoc()` method** is used for sending data to the backend (Firestore). The `getDocs()` method is used for data retrieval and the `updateDoc()` method is used for updating the data. The `deleteDoc()` method is used for data removal or deletion. Each of these methods were present in the application's JavaScript modules. It is possible to send and retrieve data from each page directly however using modular JavaScript files is more efficient. This is due to more leaner HTML pages since the send and retrieve logic is in a different location, making the code more maintainable and reusable.

The AI Solutions application was designed to be **responsive and accessible**. The responsive design was implemented using Tailwind CSS responsive utilities and custom CSS media queries. Each HTML element was designed to adapt to different screen sizes, with mobile-first approach ensuring that the website works well on smartphones, tablets, and desktop computers. The navigation menu transforms into a hamburger menu on mobile devices, images scale appropriately, forms adapt to smaller screens, and content layouts stack vertically on mobile while displaying in grids on larger screens.

To allow the **deployment and hosting function**, a hosting service was required. In this case the **Railway hosting service** was implemented to host the AI Solutions website. Railway was simple to use and understand and required minimal configuration. What was required was connecting the GitHub repository to Railway, configuring the build settings, and deploying. At first logging into Railway is required followed by creating a new project and connecting it to the repository. Through this process the deployment settings are defined, including the build command and start command. A `railway.json` or deployment configuration file can be generated that Railway uses to determine which project folder to deploy and to which Railway site link. Through this Railway would know which files to upload for hosting. From there the application was deployed using Railway's deployment system and the live link is provided (https://ai-solutions-production-5eb6.up.railway.app).

## System Evaluation

System evaluation was then carried out to determine whether all functional and non-functional requirements were met. **Blackbox testing** is where functional and non-functional requirements are evaluated without knowledge of the application's inner workings. Post development a system test table was drawn that displayed the functions being tested. If there were any prerequisites required for the function to work they were displayed. Test cases were present for each function. These detailed what a user would typically do when making use of that function. Details on the expected results were present explaining the correct output if the function works properly. A pass or fail column was there to mark whether the function works or not.

The AI Solutions application being a website meant that it would be accessible to various users. This meant that black box testing was sufficient and white box was not necessary for initial evaluation. Those testing it were not necessarily software developers. Meaning it was not necessary for them to know the inner working of the application. The applications compatibility with various browsers was tested. About four major browsers were used to test the application. **Google Chrome, Microsoft Edge, Mozilla Firefox, and Safari** were used. The AI Solutions website was found to be compatible with all the mentioned browsers after testing, with all features functioning correctly including navigation, form submission, chatbot interactions, and admin panel access.

**Responsive design testing** was conducted across different devices and screen sizes. The website was tested on desktop computers (1920px, 1366px), tablets (768px, 1024px), and mobile devices (375px, 414px) to ensure that all pages, navigation, forms, and interactive elements function correctly and display properly on all screen sizes. The mobile navigation menu was tested to verify that it toggles correctly, the contact form was tested to ensure it adapts to smaller screens, and the admin panel table was tested to verify that it displays correctly on mobile devices with proper text wrapping and column hiding.

**Functional testing** was performed for all major features. The contact form was tested with various input scenarios including valid submissions, invalid email formats, missing required fields, and edge cases. The AI chatbot was tested with different user queries to verify keyword matching and response accuracy. The admin panel was tested for authentication (correct and incorrect credentials), data retrieval, status updates, and filtering functionality. All 17 pages were tested to verify correct navigation, content display, image loading, and interactive functionality.

**Security testing** was conducted for the admin panel to ensure that unauthorized users cannot access sensitive customer inquiry data. The authentication mechanism was tested to verify that invalid credentials are rejected, unauthenticated users are prevented from accessing the admin dashboard, and successful authenticated users are granted access privileges. Input validation was tested to ensure that malicious data cannot be submitted through the contact form.

## Conclusion

The manner in which all of these steps were implemented displayed the sequential nature of a waterfall model and flexible nature of the agile model. The requirements were fully understood and agreed upon with the client from the beginning. They were fixed and not going to change significantly. The design stage was carried out and the appropriate outcomes were met. Though minor changes were made after some time, such as adjustments to color schemes and layout refinements. During development features were tested, and if any issues arose debugging was carried out. This was done in iterations until the application functioned accordingly. Responsive design issues were identified and fixed, form validation was refined, and the admin panel functionality was improved through iterative testing and debugging. Once functioning accordingly, the application was then deployed to Railway hosting platform, making it accessible to users worldwide through the live URL.

---

**Last Updated:** 2025-01-27  
**Project:** AI Solutions Website  
**Author:** Aung Hein Het

